---
title: "Transformations, Forecasting and Bias Correction"
subtitle: "Chapter 5: Lesson 2"
format:
  html:
    embed-resources: true
editor: source
  markdown: 
    wrap: 72
sidebar: false
---

```{r}
#| include: false
# Load packages ----

if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  # Interactive plots
  plotly, # Interactive visualizations, loaded before tidyverse so it overwrite dplyr::select(). Note: High conflict Potential

  # Core packages
  MASS, # MVNorm, loaded before tidyverse so it doesn't overwrite dplyr::select()
  tidyverse, # This will also load the dependencies; dplyr, readr, stringr, tibble, tidyr, purrr, forcats, gglot2, & lubridate

  # Data manipulation
  tsibble, # Tidyverse Temporal data
  tsibbledata, # Sample Tsibble datasets

  # Statistical modeling (GLS - Chpt 6-7)
  nlme, # loaded before feasts to avoid ACF() conflict
  tidymodels, # for GLS, This will also load the dependencies; broom, rsample, dials, tune, infer, workflows, modeldata, workflowsets, parsnip, yardstick, & recipies. Note: High conflict Potential
  multilevelmod, # for GLS
  broom.mixed, # for GLS

  # TS modeling and forecasting
  fable,# Forecasting Models for Tidy Time Series, Note: High conflict Potential
  feasts, # collection of features, decomposition methods, statistical summaries and graphics for tsibble data, Loaded after nlme to avoid ACF() conflict
  fable.prophet, # Converts prophet (forecasting) package for fable workflow

  # Data exploration & visualization
  patchwork, # Multiple plot outputs
  ggthemes, # Plot styling
  see,  # okabeito color scheme
  ggokabeito,  # colorblind palette

  # Reporting & output
  kableExtra, # Create nice-looking tables from data.frames
  rio, # Easy import/export of data between R and other software
  gt, # Grammar of Tables for advanced table creation
  quarto, # For generating reports in LaTeX format

  # Additional packages
  tidyquant # Quantitative analysis tools using tidyverse principles, This will also load the dependencies; PerformanceAnalytics, xts, & zoo. Important Masks: ‘package:base’: as.Date, as.Date.numeric. Note: High conflict Potential
)
################# WARNING: DO NOT USE mosaic. IT MESSES UP THE DECOMPOSITION. #need to test loading this in the front, might be ok

# Palette ----
palette("okabeito")

okabeito_colors_list <- c(
  `orange` = "#E69F00",
  `light blue` = "#56B4E9",
  `green` = "#009E73",
  `yellow` = "#F0E442",
  `blue` = "#0072B2",
  `red` = "#D55E00",
  `purple` = "#CC79A7",
  `grey` = "#999999",
  `black` = "#000000",
  `sky blue` = "#56B4E9",
  `bluish green` = "#009E73",
  `vermillion` = "#D55E00",
  `reddish purple` = "#CC79A7",
  `dark yellow` = "#F5C710",
  `amber` = "#F5C710"
)

# Definition
emdash <- "—"
endash <- "–"

# Rounding ----
## Round Dataframe ----
round_df <- function(df, digits) {
  nums <- vapply(df, is.numeric, FUN.VALUE = logical(1))
  df[,nums] <- round(df[,nums], digits = digits)
  return(df)
}


# THIS IS NOT WORKING RIGHT>>>>
autoround_df <- function(df) {
  nums <- vapply(df, is.numeric, FUN.VALUE = logical(1))
  df[,nums] <- round(df[,nums], digits = 6 + floor(-log(abs(min(df[,nums])), base = 10)))
  # return(df)

  return(df |> round_df(1))
}

# Used to create a table with ellipses in the middle

row_of_vdots <- function(df) {
  temp_df <- df |>
    # mutate(across(everything(), as.character)) |>
    head(1)

  for (j in 1:ncol(temp_df)) {
    if (names(temp_df[j]) == "sign") {
      temp_df[1,j] = " "
    } else {
      temp_df[1,j] = "⋮"
    }
  } # for

  return(temp_df)
}

concat_partial_table <- function(df, nrow_head, nrow_tail, decimals = 3) {
  temp_df <- convert_df_to_char(df, decimals)

  out_df <- head(temp_df, nrow_head) |>
    bind_rows(row_of_vdots(temp_df)) |>
    bind_rows(tail(temp_df, nrow_tail))

  return(out_df)
}

display_partial_table <- function(df, nrow_head, nrow_tail, decimals = 3, min_col_width = "0in") {
  concat_partial_table(df, nrow_head, nrow_tail, decimals) |>
    display_table(min_col_width)
}

display_table <- function(df, min_col_width = "0in") {
  df |>
    knitr::kable(format = "html", align='ccccccccccccccccc', escape = FALSE, width = NA, row.names = FALSE) |>
    kable_styling(full_width = FALSE, "striped") |>
    column_spec(1:ncol(df), width_min = min_col_width)
}

display_arima_models <- function(models_ts) {
  # Identify "best" models
  extrema <- models_ts |>
    reframe(
      sigma2 = which(min(sigma2)==sigma2),
      log_lik = which(max(log_lik)==log_lik),
      AIC = which(min(AIC)==AIC),
      AICc = which(min(AICc)==AICc),
      BIC = which(min(BIC)==BIC)
    )
  # Format the table
  models_ts |>
    select(-ar_roots, -ma_roots) |>
    rename(Model = ".model") |>
    autoround_df() |>
    format_cells(rows = unique(extrema$sigma2), cols = 2, "bold") |>
    format_cells(rows = unique(extrema$log_lik), cols = 3, "bold") |>
    format_cells(rows = unique(extrema$AIC), cols = 4, "bold") |>
    format_cells(rows = unique(extrema$AICc), cols = 5, "bold") |>
    format_cells(rows = unique(extrema$BIC), cols = 6, "bold") |>
    display_table()
}

# Rounds a value to a specific number of places and returns a character string
round_as_text <- function(x, places) {
  return(as.character(round(x,12)))
}

# Converts a dataframe to char and rounds the values to a specified number of places
convert_df_to_char <- function(df, decimals = 3) {
  out_df <- df |>
    as.data.frame() |>
    mutate_if(is.numeric, round, digits=decimals) |>
    mutate(across(everything(), as.character))
  return(out_df)
}

# Change a df to character, round, and set one specific value to ""
blank_out_one_cell_in_df <- function(df, row_num, col_num, decimals = 3) {
  out_df <- df |>
    convert_df_to_char(decimals)

  out_df[row_num, col_num] <- ""

  return(out_df)
}

# Returns "" for all cells except the first ncols_to_keep columns and nrows_to_keep rows
# Numeric values are rounded to "decimals" places
blank_out_cells_in_df <- function(df, ncols_to_keep = 2, nrows_to_keep = 0, decimals = 3) {
  out_df <- df |>
    convert_df_to_char(decimals)

  for (i in (nrows_to_keep + 1) : nrow(df))
    for (j in (ncols_to_keep + 1) : ncol(df)) {
      out_df[i,j] <- ""
    }
  return(out_df)
}


# Returns "" for all cells except the first ncols_to_keep columns and nrows_to_keep rows
# Numeric values are rounded to "decimals" places
blank_out_partial_row <- function(df, row_number = nrow(df), first_column_number = 2, last_column_number = ncol(df), decimals = 3) {
  out_df <- df |>
    convert_df_to_char(decimals)

  for (j in first_column_number:last_column_number) {
    out_df[row_number,j] <- ""
  }

  return(out_df)
}


# Replace all NAs with a character
replace_na_with_char <- function(df, new_character = "", decimals = 3) {
  out_df <- df |>
    convert_df_to_char(decimals) |>
    mutate(
      across(everything(), ~replace_na(.x, new_character))
    )
  return(out_df)
}

## This is the preferred function for replacing text with any character
replace_cells_with_char <- function(df, rows, cols, new_char = "", decimals = 3){
  for (r in rows){
    for(c in cols){

      # Make sure values are not factors
      df[[c]] <- as.character( df[[c]])

      # Update formatting
      df[r, c] <- new_char
    }
  }

  return(df)
}

#################################### USE THIS CODE TO REVISE MY PREVIOUS FUNCTIONS! ###############################

###### Format text cells in a data frame
#
# https://stackoverflow.com/questions/28166168/how-to-change-fontface-bold-italics-for-a-cell-in-a-kable-table-in-rmarkdown
format_cells <- function(df, rows ,cols, value = c("italics", "bold", "strikethrough")){

  # select the correct markup
  # one * for italics, two ** for bold
  map <- setNames(c("*", "**", "~~"), c("italics", "bold", "strikethrough"))
  markup <- map[value]

  for (r in rows){
    for(c in cols){

      # Make sure values are not factors
      df[[c]] <- as.character( df[[c]])

      # Update formatting
      df[r, c] <- paste0(markup, df[r, c], markup)
    }
  }

  return(df)
}
#### Example of use:
# library(tidyverse)
#
# df <- data.frame(char = c('a','b','c'),
#                  num = c(1,2,3))
#
# df %>%
#   format_cells(1, 1, "italics") %>%
#   format_cells(2, 2, "bold") %>%
#   format_cells(3, 1:2, "strikethrough") %>%
#   knitr::kable()

###### Compute sum or mean of numeric variables in a df

append_sum_to_df <- function(df, label = "Sum") {
  df <- df %>%
    bind_rows(summarise_all(., ~if(is.numeric(.)) sum(., na.rm = TRUE) else label))
  return(df)
}

append_mean_to_df <- function(df, label = "Mean") {
  df <- df %>%
    bind_rows(summarise_all(., ~if(is.numeric(.)) mean(., na.rm = TRUE) else label))
  return(df)
}

sum_of_columns <- function(df, label = "Sum") {
  row <- df %>%
    summarise_all(., ~if(is.numeric(.)) sum(., na.rm = TRUE) else label)
  return(row)
}

mean_of_columns <- function(df, label = "Mean") {
  row <- df %>%
    summarise_all(., ~if(is.numeric(.)) mean(., na.rm = TRUE) else label)
  return(row)
}

sum_of_columns_divided_by_n <- function(df, label, n = nrow(df)) {
  row <- df %>%
    summarise_all(., ~if(is.numeric(.)) sum(., na.rm = TRUE)/n else label)
  return(row)
}



insert_blank_last_row <- function(df, label = "sum", value = "", decimals = 3) {
  temp_df <- df |>
    bind_rows(df |> tail(1))
  convert_df_to_char(decimals)
  num_rows <- nrow(temp_df)
  temp_df[num_rows, ] <- value
  temp_df[num_rows, 1] <- label
  return(temp_df)
}


########### Compute moving average
compute_moving_average <- function(df, variable, periods = 12) {
  sum <- 0

  for (i in 1:(periods / 2)) {
    sum <- sum + lead(eval(substitute(variable), df), i)           # x_{t+i}
    sum <- sum + lag(eval(substitute(variable), df), i)            # x_{t-i}
  }
  sum <- sum + eval(substitute(variable), df)
  sum <- sum - lag(eval(substitute(variable), df), periods / 2) / 2
  sum <- sum - lead(eval(substitute(variable), df), periods / 2) / 2
  df$m_hat <- sum / periods
  return(df)
}

# # # # # # # # # # # # # Testing
# set.seed(1)
# x <- rnorm(100,5,2)
# df1 <- data.frame(x=x)
#
# df1 |>
#   compute_moving_average(x, 12) |>
# mutate( m_hat2 =
#           ( 1 / 2 * lag(x,6) + lag(x,5) + lag(x,4) + lag(x,3) + lag(x,2) + lag(x) + x + lead(x,1) + lead(x,2) + lead(x,3) + lead(x,4) + lead(x,5) + 1 / 2 * lead(x,6)) /12
# ) |> View()


########### String manipulation

# Returns "char" right-most characters of "string"
right <- function (string, char) {
  substr(string, nchar(string)-(char-1), nchar(string))
}

# Returns "char" left-most characters of "string"
left <- function (string, char) {
  substr(string, 1, char)
}

##########################################################################
# These functions color cells in a data frame of character vectors
# Works
color_specific_cell <- function(df, row_num, col_num, color) {
  df[row_num, col_num] = cell_spec(df[row_num, col_num], color = color)
  return(df)
}

# -------- THIS ONE IS NOT WORKING ----------
color_specific_row <- function(df, row_num, color) {
  for (j in 1:ncol(df)) {
    color_specific_cell(df, row_num, j, color)
  }
  return(df)
}

# -------- THIS ONE IS NOT WORKING ----------
color_last_row <- function(df, color) {
  color_specific_row(df, nrow(df), color)
  return(df)
}

# Works
color_last_row2 <- function(df, color) {
  for (j in 1:ncol(df)) {
    df[nrow(df), j] = cell_spec(df[nrow(df), j], color = color)
  }
  return(df)
}
# Works
color_2nd_to_last_row2 <- function(df, color) {
  for (j in 1:ncol(df)) {
    df[nrow(df)-1, j] = cell_spec(df[nrow(df)-1, j], color = color)
  }
  return(df)
}
##########################################################################



#############################################

#

get_toy_data <- function(n = 10, mu = 0, sigma = 3, rho = 0.99, random_seed = 997) {
  set.seed(random_seed)

  # build population correlation matrix
  tmp.r <- matrix(rho, n, n)
  tmp.r <- tmp.r^abs(row(tmp.r)-col(tmp.r))

  return( round(mvrnorm(1, rep(mu,n), sigma^2 * tmp.r),1) )
}


#############################################

deg2rad <- function (x)
{
  x/180 * base::pi
}

rad2deg <- function (x)
{
  x/base::pi * 180
}




################## Holt-Winters ####################

holt_winters_additive_forecast <- function(data, value_var, alpha = 0.2, beta = 0.2, gamma = 0.2, p = 12, a1 = NULL, b1 = NULL, s1 = NULL) {
  # Assuming 'data' is a tsibble with a column 'value'
  at <- numeric(nrow(data))
  bt <- numeric(nrow(data))
  st <- numeric(nrow(data))

  at[1] <- ifelse(!is.null(a1), a1, data[[value_var]][1])
  bt[1] <- ifelse(!is.null(b1), b1, (1 / p) * mean( data[[value_var]][(p+1):(2*p)] - data[[value_var]][1:p] ))
  st[1:p] <- ifelse(!is.null(s1), s1, 0)

  # First cycle
  for (t in 2:p) {
    at[t] <- alpha * (data[[value_var]][t] - st[t - 0 * p ]) + (1 - alpha) * (at[t - 1] + bt[t - 1])
    bt[t] <- beta * (at[t] - at[t - 1]) + (1 - beta) * bt[t - 1]
  }

  for (t in (p + 1):nrow(data)) {
    at[t] <- alpha * (data[[value_var]][t] - st[t - p]) + (1 - alpha) * (at[t - 1] + bt[t - 1])
    bt[t] <- beta * (at[t] - at[t - 1]) + (1 - beta) * bt[t - 1]
    st[t] <- gamma * (data[[value_var]][t] - at[t]) + (1 - gamma) * st[t - p]
  }

  data <- data %>%
    mutate(estimated_level = at, estimated_slope = bt, estimated_seasonal = st)

  data %>% return()
}



expand_holt_winters_df_old <- function(df, date_var, value_var, p = 12, predict_periods = 18) {
  # Note that p must be < nrow(df)
  # Note that predict_periods must be < nrow(df)

  # Create new variables
  df$date <- df[[date_var]]
  df$t <- 1:nrow(df)  # Create column t
  df$x_t <- df[[value_var]]

  df2 <- df |>
    # select(date, x_t) |>  # This deletes all variables in original file
    mutate(
      a_t = as.numeric(NA),
      b_t = as.numeric(NA),
      s_t = as.numeric(NA),
      xhat_t = as.numeric(NA)
    )

  header <- df2 |>
    head(p + 1) |>
    mutate(
      date = date - max(date) + min(date),
      t = t - p,
      x_t = NA
    ) |>
    head(p)

  footer <- df2 |>
    tail(predict_periods + 1) |>
    mutate(
      date = date - min(date) + max(date),
      t = t + predict_periods,
      x_t = NA
    ) |>
    tail(predict_periods)


  df_final <- df_final <- as.data.frame(header)|>
    bind_rows(as.data.frame(df2)) |>
    bind_rows(as.data.frame(footer))
  df_tsibble <- df_final |> as_tsibble(index = date)

  return(df_tsibble)
}

hw_additive_slope_additive_seasonal <- function(df, date_var, value_var, p = 12, predict_periods = 18, alpha = 0.2, beta = 0.2, gamma = 0.2, s_initial = rep(0,p)) {

  # Get expanded data frame
  df <- df |> expand_holt_winters_df_old(date_var, value_var, p, predict_periods)

  # Fill in prior belief about s_t
  for (t in 1:p) {
    df$s_t[t] <- s_initial[t]
  }

  # Fill in first row of values
  offset <- p # number of header rows to skip
  df$a_t[1 + offset] <- df$x_t[1 + offset]
  df$b_t[1 + offset] <- (1 / p) * mean(df$x_t[(p + 1 + offset):(2 * p + offset)] - df$x_t[(1 + offset):(p + offset)])
  df$s_t[1 + offset] <- (1 - gamma) * df$s_t[1]

  # Fill in remaining rows of body of df with values
  for (t in (2 + offset):(nrow(df) - predict_periods) ) {
    df$a_t[t] = alpha * (df$x_t[t] - df$s_t[t-p]) + (1 - alpha) * (df$a_t[t-1] + df$b_t[t-1])
    df$b_t[t] = beta * (df$a_t[t] - df$a_t[t-1]) + (1 - beta) * df$b_t[t-1]
    df$s_t[t] = gamma * (df$x_t[t] - df$a_t[t]) + (1 - gamma) * df$s_t[t-p]
  }

  df <- df |>
    mutate(k = ifelse(row_number() >= nrow(df) - predict_periods, row_number() - (nrow(df) - predict_periods), NA))

  # Fill in forecasted values
  offset <- nrow(df) - predict_periods
  for (t in offset:nrow(df)) {
    df$s_t[t] = df$s_t[t - p]
    df$xhat_t[t] = df$a_t[offset] + df$k[t] * df$b_t[offset] + df$s_t[t - p]
  }

  # Delete temporary variable k
  df <- df |> select(-k)

  return(df)
}


###### For Chapter 3 Lesson 5
hw_additive_slope_multiplicative_seasonal <- function(df, date_var, value_var, p = 12, predict_periods = 18, alpha = 0.2, beta = 0.2, gamma = 0.2, s_initial = rep(1,p)) {

  # Get expanded data frame
  df <- df |> expand_holt_winters_df_old(date_var, value_var, p, predict_periods)

  # Fill in prior belief about s_t
  for (t in 1:p) {
    df$s_t[t] <- s_initial[t]
  }

  # Fill in first row of values
  offset <- p # number of header rows to skip
  df$a_t[1 + offset] <- df$x_t[1 + offset]
  df$b_t[1 + offset] <- (1 / p) * mean(df$x_t[(p + 1 + offset):(2 * p + offset)] - df$x_t[(1 + offset):(p + offset)])
  df$s_t[1 + offset] <- df$s_t[1]

  # Fill in remaining rows of body of df with values
  for (t in (2 + offset):(nrow(df) - predict_periods) ) {
    df$a_t[t] = alpha * (df$x_t[t] / df$s_t[t-p]) + (1 - alpha) * (df$a_t[t-1] + df$b_t[t-1])
    df$b_t[t] = beta * (df$a_t[t] - df$a_t[t-1]) + (1 - beta) * df$b_t[t-1]
    df$s_t[t] = gamma * (df$x_t[t] / df$a_t[t]) + (1 - gamma) * df$s_t[t-p]
  }

  df <- df |>
    mutate(k = ifelse(row_number() >= nrow(df) - predict_periods, row_number() - (nrow(df) - predict_periods), NA))

  # Fill in forecasted values
  offset <- nrow(df) - predict_periods
  for (t in (offset+1):nrow(df)) {
    df$s_t[t] = df$s_t[t - p]
    df$xhat_t[t] = (df$a_t[offset] + df$k[t] * df$b_t[offset]) * df$s_t[t - p]
  }
  df$xhat_t[offset] = (df$a_t[offset] + df$k[offset] * df$b_t[offset]) * df$s_t[offset] #### NOTE THIS ISSUE!!!

  # Delete temporary variable k
  df <- df |> select(-k)

  return(df)
}

################## Holt-Winters ####################

expand_holt_winters_df <- function(df, date_var, value_var, p = 12, predict_periods = 18, round_to = "day") {
  # Ensure date is in Date format
  df[[date_var]] <- as.Date(df[[date_var]])

  # Check if all dates have the same day component
  same_day <- all(day(df[[date_var]]) == day(df[[date_var]][1]))

  start_date <- min(df[[date_var]])
  end_date <- max(df[[date_var]])

  if(round_to == "month" | round_to == "Month") {
    # Calculate the difference in months between the first two rows
    date_diff_months <- as.integer(round(as.numeric(difftime(df[[date_var]][2], df[[date_var]][1], units = "days")) / 30))

    # Create sequences for header and footer with distinct months
    header_dates <- seq.Date(from = start_date %m-% months(date_diff_months * p), by = paste0(date_diff_months, " months"), length.out = p)
    footer_dates <- seq.Date(from = end_date %m+% months(date_diff_months), by = paste0(date_diff_months, " months"), length.out = predict_periods)
  } else {
    # Calculate the difference in days between the first two rows
    date_diff <- as.numeric(df[[date_var]][2] - df[[date_var]][1])
    # Create the header by generating a sequence of dates before the first date
    header_dates <- seq(from = start_date - date_diff*p, by = date_diff, length.out = p)

    # Create the footer by generating a sequence of dates after the last date
    footer_dates <- seq(from = end_date + date_diff, by = date_diff, length.out = predict_periods)

  }
  # Combine header, original df, and footer
  header_df <- data.frame(date = header_dates, x_t = rep(NA, p), section="H")
  footer_df <- data.frame(date = footer_dates, x_t = rep(NA, predict_periods), section="F")


  # Ensure original df has the necessary columns
  df$x_t <- df[[value_var]]
  df$date <- df[[date_var]]
  df <- df |>
    # select(date, x_t) |>  # This deletes all variables in original file
    mutate(
      a_t = as.numeric(NA),
      b_t = as.numeric(NA),
      s_t = as.numeric(NA),
      xhat_t = as.numeric(NA),
      section = "B"
    )

  # Combine all parts
  df_final <- bind_rows(header_df, as.data.frame(df), footer_df)
  #df_final$date <- format(df_final$date, output_date_format)
  # Convert to tsibble if necessary
  df_tsibble <- as_tsibble(df_final, index = date)

  return(df_tsibble)
}

holt_winters_forecast <- function(df, date_var, value_var, p = 12, predict_periods = 18, alpha = 0.2, beta = 0.2, gamma = 0.2, s_initial = rep(0, p), round_to, slope_type = "add", season_type = "add") {
  # Get expanded data frame with section column
  df <- df |> expand_holt_winters_df(date_var, value_var, p, predict_periods, round_to)

  ### Header
  # Initialize the seasonal component for the header section
  df$s_t[1:p] <- s_initial


  ### Initial row of body
  # Calculate initial level and trend values based on the first period of actual data
  actual_start <- p + 1 # The start of actual data in the expanded dataframe
  df$a_t[actual_start] <- df$x_t[actual_start]

  roll_mean <- df %>%
    filter(section == "B") %>%
    mutate(roll_mean = rollmean(x_t, 7, fill = NA, align = "center")) %>%
    dplyr::select(roll_mean)
  roll_mean <- roll_mean[4,1][[1]]

  #df$b_t[actual_start] <- mean(diff(df$x_t[actual_start:(actual_start + p - 1)])) / p #chat gpt code doesn't calc correctly
  #df$b_t[actual_start] <- mean(df$x_t[(actual_start + p):(3 * p)] - df$x_t[(actual_start):(p + p)]) / p # simplified Bro Johnson code
  df$b_t[actual_start] <- (df$x_t[actual_start] - roll_mean) / df$x_t[actual_start] # period 4 of 7 period rolling average (Bro Moncayo)
  df$s_t[actual_start] <- df$s_t[1]



  ### Fill Body
  #Add + Add
  # for (t in (actual_start + 1):(nrow(df) - predict_periods)) {
  #   prior_seasonal_index <- ifelse(t <= actual_start + p, t - actual_start, t - p)
  #   df$a_t[t] <- alpha * (df$x_t[t] - df$s_t[prior_seasonal_index]) + (1 - alpha) * (df$a_t[t - 1] + df$b_t[t - 1])
  #   df$b_t[t] <- beta * (df$a_t[t] - df$a_t[t - 1]) + (1 - beta) * df$b_t[t - 1]
  #   df$s_t[t] <- gamma * (df$x_t[t] - df$a_t[t]) + (1 - gamma) * df$s_t[prior_seasonal_index]
  # }
  #
  # #Add + Mult
  # for (t in (2 + actual_start):(nrow(df) - predict_periods) ) {
  #   prior_seasonal_index <- ifelse(t <= actual_start + p, t - actual_start, t - p)
  #   df$a_t[t] = alpha * (df$x_t[t] / df$s_t[prior_seasonal_index]) + (1 - alpha) * (df$a_t[t-1] + df$b_t[t-1])
  #   df$b_t[t] = beta * (df$a_t[t] - df$a_t[t-1]) + (1 - beta) * df$b_t[t-1]
  #   df$s_t[t] = gamma * (df$x_t[t] / df$a_t[t]) + (1 - gamma) * df$s_t[prior_seasonal_index]
  # }

  for (t in (1 + actual_start):(nrow(df) - predict_periods) ) {
    prior_seasonal_index <- ifelse(t <= actual_start + p, t - actual_start, t - p)
    if (slope_type == "add" & season_type == "add"){
      df$a_t[t] <- alpha * (df$x_t[t] - df$s_t[prior_seasonal_index]) + (1 - alpha) * (df$a_t[t - 1] + df$b_t[t - 1])
      df$b_t[t] <- beta * (df$a_t[t] - df$a_t[t - 1]) + (1 - beta) * df$b_t[t - 1]
      df$s_t[t] <- gamma * (df$x_t[t] - df$a_t[t]) + (1 - gamma) * df$s_t[prior_seasonal_index]# add slope & add season
    } else if (slope_type == "add" & season_type == "mult"){
      df$a_t[t] = alpha * (df$x_t[t] / df$s_t[prior_seasonal_index]) + (1 - alpha) * (df$a_t[t-1] + df$b_t[t-1])
      df$b_t[t] = beta * (df$a_t[t] - df$a_t[t-1]) + (1 - beta) * df$b_t[t-1]
      df$s_t[t] = gamma * (df$x_t[t] / df$a_t[t]) + (1 - gamma) * df$s_t[prior_seasonal_index] # add slope & mult season
    } else if (slope_type == "mult" & season_type == "add"){
      df$a_t[t] = alpha * (df$x_t[t] + df$s_t[prior_seasonal_index]) + (1 - alpha) * (df$a_t[t-1] + df$b_t[t-1])
      df$b_t[t] = beta * (df$a_t[t] / df$a_t[t-1]) + (1 - beta) * df$b_t[t-1]
      df$s_t[t] = gamma * (df$x_t[t] + df$a_t[t]) + (1 - gamma) * df$s_t[prior_seasonal_index] # mult slope & add season
    } else {
      df$a_t[t] = alpha * (df$x_t[t] / df$s_t[prior_seasonal_index]) + (1 - alpha) * (df$a_t[t-1] + df$b_t[t-1])
      df$b_t[t] = beta * (df$a_t[t] / df$a_t[t-1]) + (1 - beta) * df$b_t[t-1]
      df$s_t[t] = gamma * (df$x_t[t] / df$a_t[t]) + (1 - gamma) * df$s_t[prior_seasonal_index] # mult slope & mult season
    }
  }

  ### Footer
  # Prepare for forecasting
  last_actual_t <- nrow(df) - predict_periods
  forecast_start <- last_actual_t

  # Forecast future values
  for (t in forecast_start:nrow(df)) {
    forecast_index <- t - last_actual_t
    df$s_t[t] <- df$s_t[t - p] # Carry forward the seasonal component
    if (slope_type == "add" & season_type == "add"){
      df$xhat_t[t] <- (df$a_t[last_actual_t] + forecast_index * df$b_t[last_actual_t]) + df$s_t[t - p] # add slope & add season
    } else if (slope_type == "add" & season_type == "mult"){
      df$xhat_t[t] <- (df$a_t[last-actual_t] + forecast_index * df$b_t[last-actual_t]) * df$s_t[t - p] # add slope & mult season
    } else if (slope_type == "mult" & season_type == "add"){
      df$xhat_t[t] <- (df$a_t[last-actual_t] + df$b_t[last-actual_t]^(forecast_index)) + df$s_t[t - p] # mult slope & add season
    } else {
      df$xhat_t[t] <- (df$a_t[last-actual_t] + df$b_t[last-actual_t]^(forecast_index)) * df$s_t[t - p] # mult slope & mult season
    }
  }


  return(df)
}
```

```{=html}
<script type="text/javascript">
 function showhide(id) {
    var e = document.getElementById(id);
    e.style.display = (e.style.display == 'block') ? 'none' : 'block';
 }
 
 function openTab(evt, tabName) {
    var i, tabcontent, tablinks;
    tabcontent = document.getElementsByClassName("tabcontent");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    document.getElementById(tabName).style.display = "block";
    evt.currentTarget.className += " active";
 }    
</script>
```

## Learning Outcomes

\#{{< include outcomes/_chapter_5_lesson_4_outcomes.qmd >}}

## Preparation

-   Read Sections 5.7, 5.9-5.11

## Learning Journal Exchange (10 min)

-   Review another student's journal

-   What would you add to your learning journal after reading another student's?

-   What would you recommend the other student add to their learning journal?

-   Sign the Learning Journal review sheet for your peer

<!-- {{< include _packages.qmd >}} -->

## Class Activity: Simulate an Exponential Trend with a Seasonal Component (15 min)

There are a lot of processes that grow over time at a regular rate. These growing variables may be modeled as exponential functions. Exponential functions can be difficult to model in a linear regression, so we can use a logarithmic transformation to make the function linear and easier to work with.

We will simulate code that has a seasonal component and impose an exponential trend.

::: {.callout-note icon="false" title="Figures" collapse="false"}
<!-- Begin hiding code for Figures -->

@fig-simTSplot shows the simulated time series and it's natural logarithm.

```{r}
#| label: fig-simTSplot
#| fig-cap: "Time plot of the time series (left) and the natural logarithm of the time series (right)"
#| code-fold: true
#| code-summary: "Show the code"
#| results: asis
#| fig-height: 3.5

n_years  <- 9
n_months <- n_years * 12
sigma    <- 0.05

# Dates
dates_seq <- seq(
  floor_date(now(), unit = "year"),
  length.out = n_months + 1,
  by = "-1 month"
) |>
  floor_date(unit = "month") |>
  sort() |>
  head(n_months)

t <- 1:n_months

# Month-of-year index: 1 = Jan, ..., 12 = Dec
month_index  <- ((t - 1) %% 12) + 1
month_factor <- factor(month_index, levels = 1:12, labels = month.abb)

# ----- KEY PART: indicator-style seasonal effects by month -----

# Compute the seasonal effect for each month-of-year
# using your original harmonic coefficients, but evaluated
# once per month instead of for every t.
seasonal_effect_by_month <- sapply(1:12, function(m) {
  0.03 * sin(2 * pi * 1 * m / 12) + 0.04 * cos(2 * pi * 1 * m / 12) +
  0.05 * sin(2 * pi * 2 * m / 12) + 0.03 * cos(2 * pi * 2 * m / 12) +
  0.01 * sin(2 * pi * 3 * m / 12) + 0.005 * cos(2 * pi * 3 * m / 12)
})

# Map each time point to its month-specific seasonal effect
seasonal_term <- seasonal_effect_by_month[month_index]

# AR(2) noise as before
random_ar <- arima.sim(model = list(ar = c(0.5, 0.2)),
                       n = n_months, sd = 0.02)

# Build tsibble
sim_ts <- tibble(
  t       = t,
  dates   = dates_seq,
  month   = month_factor,
  random  = random_ar,
  seasonal = seasonal_term,
  x_t     = exp(2 + 0.015 * t + seasonal + random)
) |>
  mutate(std_t = (t - mean(t)) / sd(t)) |>
  as_tsibble(index = dates)

# (Optional) create explicit 0/1 indicator columns for each month
sim_ts <- sim_ts |>
  bind_cols(
    model.matrix(~ month - 1, data = sim_ts) |>
      as_tibble()
  )

# Plots
plot_raw <- sim_ts |>
  autoplot(x_t) +
  labs(
    x = "Month",
    y = "x_t",
    title = "Simulated Time Series"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

plot_log <- sim_ts |>
  autoplot(log(x_t)) +
  labs(
    x = "Month",
    y = "log(x_t)",
    title = "Logarithm of Simulated Time Series"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

plot_raw | plot_log
```

We will use (natural) logarithm of the time series before fitting any linear models. So, our response variable will be $\log(x_t)$, rather than $x_t$.

Even though there is no visual evidence of curvature in the trend for the logarithm of the time series, we will start by fitting a model that allows for a cubic trend. (In practice, we would probably not fit this model. However, we want to understand how to evaluate among different model specifications.
:::

### Model Selection Information Criteria: Balancing Fit and Complexity

In a previous activity, we compared the Cubic, Quadratic, and Linear models. You might have noticed that adding more variables (like $t^2$ and $t^3$) almost always increases the $R^2$ value and reduces the residual sum of squares. However, a model that hugs the training data too tightly (overfitting) often fails when forecasting new data.The question that Inforcation Criteria answer is how to select the best forecasting model, we need a way to penalize complexity. We use Information Criteria to find the "Goldilocks" model: one that fits the data well but remains simple enough to generalize.

::: {.callout-tip icon="false"}
### AIC, AICc, and BIC

The motivation behind Information Criteria is based on Parsimony. Parsimony is often associated with Occam's Razor: Given two models with similar predictive power, the simpler one is preferred. We want the model that explains the signal with the fewest possible parameters.The structure of all Information Criteria follow the same basic structure:

$$\text{IC} = \text{Badness of Fit} + \text{Penalty for Complexity}$$ We want to minimize this value. The "Badness of Fit" is measured by $-2\log(\mathcal{L})$, where $\mathcal{L}$ is the likelihood (how probable the data is given the model). The "Penalty" increases as we add parameters ($k$).1.

##### AIC (Akaike Information Criterion)

$$AIC = -2\log(\mathcal{L}) + 2k$$

The AIC is founded on Information Theory. It estimates the relative amount of information lost when a model is used to represent the process that generated the data (using Kullback-Leibler divergence). Intuitively, it tries to predict which model will have the lowest prediction error on future data. The AIC is xxcellent for forecasting. It tends to prefer slightly more complex models than BIC.

##### AICc (Corrected AIC)

$$AICc = AIC + \frac{2k(k+1)}{n - k - 1}$$

When the sample size ($n$) is small, the standard AIC tends to select models that are too complex (overfitting). In practice, use AICc instead of AIC when $n$ is finite. As $n \to \infty$, AICc converges to AIC. Since time series data is often limited, AICc is a great metric.

##### BIC (Bayesian Information Criterion)

$$BIC = -2\log(\mathcal{L}) + k\ln(n)$$ The BIC is founded on Bayesian Inference. It attempts to estimate the probability that a specific model is the "true" model among the set of candidates.Notice the penalty is $k\ln(n)$ rather than $2k$. Since $\ln(n) > 2$ for any dataset with $n > 7$, BIC penalizes complexity much more strictly than AIC. Use BIC when you want your model choice to be conservative given uncertainty in modeling or forecasting. It is great for explanatory modeling (understanding relationships), but sometimes under-fits for forecasting purposes.Summary Rule of ThumbLower is Better. The absolute number means nothing; only the difference between models matters.If AICc and BIC disagree, rely on AICc for forecasting and BIC for explanation.

In our specific simulated example below, the Linear model had the lowest AICc and BIC. Even though the Cubic model had more parameters to "wiggle" and fit the training data, the Information Criteria penalized those extra parameters ($\beta_2$ and $\beta_3$) because they did not contribute enough information to justify their "cost."
:::

<!-- End figures -->

::: panel-tabset
## Cubic

#### Cubic Model

After taking the (natural) logarithm of $x_t$, we fit a cubic model to the log-transformed time series.

##### Full Cubic Model

\begin{align*}
  \log(x_t) &= \beta_0 
            + \beta_1 \left( \frac{t - \mu_t}{\sigma_t} \right) 
            + \beta_2 \left( \frac{t - \mu_t}{\sigma_t} \right)^2 
            + \beta_3 \left( \frac{t - \mu_t}{\sigma_t} \right)^3 + s_t + z_t
\end{align*}
\begin{align*}
  s_t=
    
    \begin{cases}
        \Delta\beta_2 , & t = 2, 14, 26, \ldots ~~~~ ~~(February) \\
        \Delta\beta_3 , & t = 2, 14, 26, \ldots ~~~~ ~~(March) \\
        ~~~~~~~~⋮ & ~~~~~~~~~~~~⋮ \\
        \Delta\beta_{12} , & t = 12, 24, 36, \ldots ~~~~ (December) 
      \end{cases}
\end{align*}

```{r}
#| label: simulatedExponentialTS1
#| code-fold: true
#| code-summary: "Show the code"

# Cubic model with standardized time variable

cubic_lm <- sim_ts |>
  model(cubic = TSLM(log(x_t) ~ std_t + I(std_t^2) + I(std_t^3) + month )) #Jan is ommited 
cubic_lm |>
  tidy() |>
  mutate(sig = p.value < 0.05)
```

Note that neither the quadratic nor the cubic terms are statistically significant in this model.

<!-- End of cubic model -->

## Quadratic

#### Quadratic Model

We now fit a quadratic model to the log-transformed time series.

##### Full Quadratic Model

The full model with a quadratic trend is written as:

\begin{align*}
  \log(x_t) &= \beta_0 
            + \beta_1 \left( \frac{t - \mu_t}{\sigma_t} \right) 
            + \beta_2 \left( \frac{t - \mu_t}{\sigma_t} \right)^2 + s_t  + z_t
\end{align*}
\begin{align*}
  s_t=
    
    \begin{cases}
        \Delta\beta_2 , & t = 2, 14, 26, \ldots ~~~~ ~~(February) \\
        \Delta\beta_3 , & t = 2, 14, 26, \ldots ~~~~ ~~(March) \\
        ~~~~~~~~⋮ & ~~~~~~~~~~~~⋮ \\
        \Delta\beta_{12} , & t = 12, 24, 36, \ldots ~~~~ (December) 
      \end{cases}
\end{align*}

```{r}
#| label: simulatedExponentialQuadraticFull
#| code-fold: true
#| code-summary: "Show the code"

quad_lm <- sim_ts |>
  model(quad = TSLM(log(x_t) ~ std_t + I(std_t^2)  + month)) # Note sin6 is omitted
quad_lm |>
  tidy() |>
  mutate(sig = p.value < 0.05) 
```

Note the quadratic term is not significant. <!-- End of quadratic model -->

## Linear

#### Linear Model

Even though the quadratic terms were statistically significant, there is no visual indication that there is a quadratic trend in the time series after taking the logarithm. Hence, we will now fit a linear model to the log-transformed time series. We want to be able to compare the fit of models with a linear trend to the models with quadratic trends.

##### Full Linear Model

First, we fit a full model with a linear trend. We can express this model as:

\begin{align*}
  \log(x_t) &= \beta_0 
            + \beta_1 \left( \frac{t - \mu_t}{\sigma_t} \right) + s_t  + z_t
\end{align*}
\begin{align*}
  s_t=
    
    \begin{cases}
        \Delta\beta_2 , & t = 2, 14, 26, \ldots ~~~~ ~~(February) \\
        \Delta\beta_3 , & t = 2, 14, 26, \ldots ~~~~ ~~(March) \\
        ~~~~~~~~⋮ & ~~~~~~~~~~~~⋮ \\
        \Delta\beta_{12} , & t = 12, 24, 36, \ldots ~~~~ (December) 
      \end{cases}
\end{align*}

```{r}
#| label: simulatedExponentialLinearFull
#| code-fold: true
#| code-summary: "Show the code"

linear_lm <- sim_ts |>
  model(linear = TSLM(log(x_t) ~ std_t + month)) # Note sin6 is omitted
linear_lm |>
  tidy() |>
  mutate(sig = p.value < 0.05)
```

<!-- End of linear model -->
:::

#### Comparison of Fitted Models

##### AIC, AICc, and BIC

We will now compare the models we fitted above. @tbl-ModelComparison gives the AIC, AICc, and BIC of the models fitted above.

```{r}
#| label: modelComparison
#| output: false
#| code-fold: true
#| code-summary: "Show the code"

model_combined <- sim_ts |>
  model(
    cubic = TSLM(log(x_t) ~ std_t + I(std_t^2) + I(std_t^3) +month),
    quad = TSLM(log(x_t) ~ std_t + I(std_t^2) + month),
    linear = TSLM(log(x_t) ~ std_t + month )
  )

glance(model_combined) |>
  select(.model, AIC, AICc, BIC)
```

```{r}
#| label: tbl-ModelComparison
#| tbl-cap: "Comparison of the AIC, AICc, and BIC values for the models fitted to the logarithm of the simulated time series."
#| echo: false

combined_models <- glance(model_combined) |> 
  select(.model, AIC, AICc, BIC)

minimum <- combined_models |>
  reframe(
    AIC = which(min(AIC)==AIC),
    AICc = which(min(AICc)==AICc),
    BIC = which(min(BIC)==BIC)
  )

combined_models |>
  rename(Model = ".model") |>
  round_df(1) |>
  format_cells(rows = minimum$AIC, cols = 2, "bold") |>
  format_cells(rows = minimum$AICc, cols = 3, "bold") |>
  format_cells(rows = minimum$BIC, cols = 4, "bold") |>
  display_table()



```

#### Investigating Autocorrelation of the Random Component

Recall that if there is autocorrelation in the random component, the standard error of the parameter estimates tends to be underestimated. We can account for this autocorrelation using Generalized Least Squares, GLS, if needed.

##### Linear Trend

@fig-QuadACF illustrates the ACF of the model with a linear trend.

```{r}
#| label: fig-QuadACF
#| fig-cap: "ACF of model linear trend"
#| code-fold: true
#| code-summary: "Show the code"

linear_ts <- linear_lm |>
  residuals() 

acf(linear_ts$.resid, plot=TRUE, lag.max = 25)
```

Notice that the residual correlogram indicates a positive autocorrelation in the values. This suggests that the standard errors of the regression coefficients will be underestimated, which means that some predictors can appear to be statistically significant when they are not.

@fig-QuadPACF illustrates the PACF of the model with a linear trend.

```{r}
#| label: fig-QuadPACF
#| fig-cap: "PACF of model linear trend"
#| code-fold: true
#| code-summary: "Show the code"

pacf(linear_ts$.resid, plot=TRUE, lag.max = 25)
```

Only the first partial autocorrelation is statistically significant. The partial autocorrelation plot indicates that an $AR(1)$ model could adequately model the random component of the logarithm of the time series. Recall that in [Chapter 5, Lesson 1](https://byuistats.github.io/timeseries/chapter_5_lesson_1.html#FittingRegModelWithPACF), we fitted a linear regression model using the value of the partial autocorrelation function for $k=1$. This helps account for the autocorrelation in the residuals.

The first few partial autocorrelation values are:

```{r}
#| code-fold: true
#| code-summary: "Show the code"

pacf(linear_ts$.resid, plot=FALSE, lag.max = 10)
```

```{r}
#| echo: false

alphas_quad <- pacf(linear_ts$.resid, plot=FALSE, lag.max = 25) 
```

The partial autocorrelation when $k=1$ is approximately `r alphas_quad$acf[1] |> round(3)`. We will use this value as we recompute the regression coefficients.

```{r}
#| code-fold: true
#| code-summary: "Show the code"


linear_pacf <- pacf(linear_ts$.resid, plot=FALSE, lag.max = 25)
lag_1 <- linear_pacf$acf[1]

# Load additional packages
pacman::p_load(tidymodels, multilevelmod,
  nlme, broom.mixed)

temp_spec <- linear_reg() |>
  set_engine("gls", correlation = nlme::corAR1(lag_1))

temp_gls <- temp_spec |>
  fit(log(x_t) ~ std_t +month, data = sim_ts)

tidy(temp_gls) |>
  mutate(
    lower = estimate + qnorm(0.025) * std.error,
    upper = estimate + qnorm(0.975) * std.error
  ) 
```

@fig-finalFittedPlot illustrates the original time series (in black) and the fitted model (in blue). For reference, a dotted line illustrating the simple least squares line is plotted on this figure for reference. It helps highlight the exponential shape of the trend.

```{r}

```

```{r}
#| label: fig-finalFittedPlot
#| fig-cap: "Time plot of the time series and the fitted linear regression model"
#| code-fold: true
#| code-summary: "Show the code"

forecast_df <- linear_lm |> 
  forecast(sim_ts) |>
  as_tibble() |> 
  dplyr::select(std_t, .mean) |> 
  rename(pred = .mean)

sim_ts |>
  left_join(forecast_df, by = "std_t") |>
  as_tsibble(index = dates) |>
  autoplot(.vars = x_t) +
  geom_line(aes(y = pred), color = "#56B4E9", alpha = 0.75) +
    labs(
      x = "Month",
      y = "Simulated Time Series",
      title = "Time Plot of Simulated Time Series with an Exponential Trend",
      subtitle = "Predicted values based on the full linear model are given in blue"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5)
    )
```

## Small-Group Activity: Retail Sales (20 min)

@fig-RetailSalesGeneralMerch gives the total sales (in millions of U.S. dollars) for the category "all other general merchandise stores (45299)."

```{r}
#| label: fig-RetailSalesGeneralMerch
#| fig-cap: "Time plot of the total monthly retail sales for all other general merchandise stores (45299)"
#| code-fold: true
#| code-summary: "Show the code"

# Read in retail sales data for "all other general merchandise stores"
retail_ts <- rio::import("https://byuistats.github.io/timeseries/data/retail_by_business_type.parquet") |>
  filter(naics == 45299) |>
  filter(as_date(month) >= my("Jan 1998")) |>
  as_tsibble(index = month)

retail_ts |>
  autoplot(.vars = sales_millions) +
    labs(
      x = "Month",
      y = "Sales (Millions of U.S. Dollars)",
      title = paste0(retail_ts$business[1], " (", retail_ts$naics[1], ")")
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5))

```

<!-- Check Your Understanding -->

::: {.callout-tip icon="false" title="Check Your Understanding"}
Use @fig-RetailSalesGeneralMerch to explain the following questions to a partner.

-   What is the shape of the trend of this time series?
-   Which decomposition would be more appropriate: additive or multiplicative? Justify your answer.
-   Apply the appropriate transformation to the time series.
-   Fit appropriate models utilizing the indicator terms for seasonal components.
-   Determine the "best" model for these data. Justify your decision.
-   Check for autocorrelation in the random terms.
-   Use GLS to fit the model, if there is evidence of autocorrelation in the random component.
-   Plot the fitted values and the time series on the same figure.
:::

## Class Activity: Anti-Log Transformation and Bias Correction on Simulated Data (10 min)

### Forecasts for a Simulated Time Series

We can use the `forecast()` function to predict future values of this time series. The code fold below displays the output of the `forecast()` command. Note that the column labeled `x_t` (i.e. $x_t$), representing the time series is populated with information tied to a normal distribution. The mean and standard deviation specified are the estimated parameters for the distribution of the predicted values of $\log(x_t)$. If you raise $e$ to the power of the mean, you get the values in the `.mean` column.

```{r}
#| code-fold: true
#| code-summary: "Forecast of Simulated Data: Show the code"
#| results: false

# Fit model (OLS)
sim_reduced_linear_lm1 <- sim_ts |>
  model(sim_reduced_linear1 = TSLM(log(x_t) ~ std_t + month))


# Number of years / months to forecast
n_years_forecast  <- 5
n_months_forecast <- 12 * n_years_forecast

# Last observed t and date from the simulated data
last_t    <- max(sim_ts$t)
last_date <- max(sim_ts$dates)

# Build new data consistent with the indicator-variable spec
new_dat <- tibble(
  # Future time index (no overlap with observed sample)
  t = last_t + seq_len(n_months_forecast),
  
  # Future monthly dates, starting one month after the last observed date
  dates = seq(
    from = last_date %m+% months(1),
    by   = "1 month",
    length.out = n_months_forecast
  )
) |>
  mutate(
    # Month-of-year index and factor (same as in sim_ts)
    month_index = ((t - 1) %% 12) + 1,
    month = factor(month_index, levels = 1:12, labels = month.abb),
    
    # Standardized time using the *training* t from sim_ts
    std_t = (t - mean(pull(sim_ts, t))) / sd(pull(sim_ts, t))
  ) |>
  as_tsibble(index = dates)

sim_reduced_linear_lm1 |> 
  forecast(new_data = new_dat)
```

@fig-forecastSim-2 illustrates the forecasted values for the time series.

```{r}
#| label: fig-forecastSim-2
#| fig-cap: "Forecasted values of the time series with 95% confidence bands"
#| code-fold: true
#| code-summary: "Show the code"

sim_forecast_plot_regular <- sim_reduced_linear_lm1 |> 
  forecast(new_data = new_dat) |>
  autoplot(sim_ts, level = 95) +
  labs(
    x = "Month",
    y = "x_t",
    title = "Simulated Time Series"
  ) +
  theme_minimal() +
  theme(legend.position = "inset") +
  theme(
    plot.title = element_text(hjust = 0.5)
  )

sim_forecast_plot_logged <- sim_reduced_linear_lm1 |> 
  forecast(new_data = new_dat) |>
  autoplot(sim_ts, level = 95) +
  scale_y_continuous(trans = "log", labels = trans_format("log")) +
  labs(
    x = "Month",
    y = "log(x_t)",
    title = "Logarithm of Simulated Time Series"
  ) +
  theme_minimal() +
  theme(legend.position = "inset")  +
  theme(
    plot.title = element_text(hjust = 0.5)
  )

sim_forecast_plot_regular | sim_forecast_plot_logged
```

### Bias Correction

The forecasts presented above were computed by raising $e$ to the power of the predicted log-values. Unfortunately, this introduces bias in the forecasted means. This bias tends to be large if the regression model does not fit the data closely.

The textbook points out that the bias correction should only be applied for means, not for simulated values. This means that if you are simulating transformed values, and you apply the inverse of your original transformation, the resulting values are appropriate.

When we apply the inverse transform to the residual series, we introduce a bias. <!-- See p. 116 --> We can account for this bias applying one of two adjustments to our mean values. The theory behind this transformations is alluded to in the textbook, but is not essential.

There are two common patterns observed in the residual series: (1) Gaussian white noise or (2) Non-Normal values.

We can use the skewness statistic to assess the shape of the residual series. When the skewness is less than -1 or greater than 1, we say that the distribution is highly skewed. For skewness values between -1 and -0.5 or between 0.5 and 1, we say there is moderate skewness. If skewness lies between -0.5 and 0.5, the distribution is considered roughly symmetric.

<!-- Beginning of two columns -->

:::::: columns
::: {.column width="45%"}
#### Log-Normal Correction

##### Normally-Distributed Residual Series

If the residual series follows a normal distribution, we multiply the means of the forecasted values $\hat x_t$ by the factor $e^{\frac{1}{2} \sigma^2}$:

$$
  \hat x_t' = e^{\frac{1}{2} \sigma^2} \cdot \hat x_t
$$

where $\left\{ \hat x_t: t = 1, \ldots, n \right\}$ gives the values of the forecasted series, and $\left\{ \hat x_t': t = 1, \ldots, n \right\}$ is the adjusted forecasted values.
:::

::: {.column width="10%"}
<!-- empty column to create gap -->
:::

::: {.column width="45%"}
#### Emperical Correction

##### Non-Normally Distributed Residual Series

If the residual series lacks normality , then we can adjust the forecasts $\left\{ \hat x_t \right\}$ as follows:

$$
  \hat x_t' = e^{\widehat{\log x_t}} \sum_{t=1}^{n} \frac{e^{z_t}}{n}
$$

where $\left\{ \widehat{\log x_t}: t = 1, \ldots, n \right\}$ is the forecasted series obtained by fitting the log-regression model.

$\left\{ z_t \right\}$ is the residual series from this fitted model in the log-transformed units.
:::
::::::

<!-- End of two columns -->

The code given below can be used to compute the corrected mean values for the simulated data.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

sim_model_values <- sim_reduced_linear_lm1 |>
  glance()

sim_model_check <- sim_model_values |>
  mutate(
    sigma = sqrt(sigma2),
    lognorm_cf = exp((1/2) * sigma2),
    empirical_cf = sim_reduced_linear_lm1 |>
      residuals() |>
      pull(.resid) |>
      exp() |>
      mean()) |>
  select(lognorm_cf, empirical_cf)

# sim_pred <- sim_reduced_linear_lm1 |> 
#   forecast(new_data = new_dat) |>
#   mutate(.mean_correction = .mean * sim_model_check$empirical_cf) |>
#   select(t, x_t, .mean, .mean_correction)

```

The log-normal adjustment is $`r sim_model_check |> select(lognorm_cf) |> pull() |> round(5)`$, and the emperical adjustment is $`r sim_model_check |> select(empirical_cf) |> pull() |> round(5)`$. Both of these values are extremely close to 1, so they will have a negligible impact on the predicted values.

This result does not generalize. In other situations, there can be a substantial effect of this bias on the predicted means.

### Histogram of residuals

@fig-ResidualHistogramSimulatedTS-2 gives a histogram of the residuals and compute the skewness of the residual series.

```{r}
#| label: fig-ResidualHistogramSimulatedTS-2
#| fig-cap: "Histogram of the values in the residual series based on the model with a linear trend and seasonal Fourier terms where i≤3"
#| code-fold: true
#| code-summary: "Show the code"

sim_resid_df <- sim_reduced_linear_lm1 |> 
  residuals() |> 
  as_tibble() |> 
  dplyr::select(.resid) |>
  rename(x = .resid) 
  
sim_resid_df |>
  mutate(density = dnorm(x, mean(sim_resid_df$x), sd(sim_resid_df$x))) |>
  ggplot(aes(x = x)) +
    geom_histogram(aes(y = after_stat(density)),
        color = "white", fill = "#56B4E9", binwidth = 0.01) +
    geom_line(aes(x = x, y = density)) +
    theme_bw() +
    labs(
      x = "Values",
      y = "Frequency",
      title = "Histogram of Residuals from the Reduced Linear Model"
    ) +
    theme(
      plot.title = element_text(hjust = 0.5)
    )
```

We can use the command `skewness(sim_resid_df$x)` to compute the skewness of these residuals: `r skewness(sim_resid_df$x) |> round(3)`. This number is close to zero (specifically between -0.5 and 0.5,) so we conclude that the residual series is approximately normally distributed. We can apply the log-normal correction to our mean forecast values.

## Class Activity: Apple Revenue (10 min)

We take another look at the quarterly revenue reported by Apple Inc. from Q1 of 2005 through Q1 of 2012

### Visualizing the Time Series

@fig-appleTS-2 gives the time plot illustrating the quarterly revenue reported by Apple from the first quarter of 2005 through the first quarter of 2012.

```{r}
#| label: fig-appleTS-2
#| fig-cap: "Apple quarterly revenue figures (in billions of U.S. dollars) from Q1 of 2005 to Q1 of 2012; the figure on the left presents the revenue in dollars and the figure on the right gives the logarithm of the quarterly revenue; a simple linear regression line is given for reference"
#| code-fold: true
#| code-summary: "Show the code"

apple_raw <- rio::import("https://byuistats.github.io/timeseries/data/apple_revenue.csv") |>
  mutate(dates = round_date(mdy(date), unit = "quarter")) |>
  arrange(dates)

apple_ts <- apple_raw |>
  filter(dates <= my("Jan 2012")) |>
  dplyr::select(dates, revenue_billions) |>
  mutate(
    t     = row_number(),
    std_t = (t - mean(t)) / sd(t),
    # quarter-of-year as indicator-style factor
    qtr   = factor(quarter(dates), levels = 1:4, labels = paste0("Q", 1:4))
  ) |>
  as_tsibble(index = dates)

# Plots stay the same, now just using the updated apple_ts

apple_plot_regular <- apple_ts |>
  autoplot(.vars = revenue_billions) +
  stat_smooth(
    method  = "lm",
    formula = y ~ x,
    geom    = "smooth",
    se      = FALSE,
    color   = "#E69F00",
    linetype = "dotted"
  ) +
  labs(
    x = "Quarter",
    y = "Revenue (Billions USD)",
    title = "Apple Revenue (in Billions USD)"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

apple_plot_transformed <- apple_ts |>
  autoplot(.vars = log(revenue_billions)) +
  stat_smooth(
    method  = "lm",
    formula = y ~ x,
    geom    = "smooth",
    se      = FALSE,
    color   = "#E69F00",
    linetype = "dotted"
  ) +
  labs(
    x = "Quarter",
    y = "Logarithm of Revenue",
    title = "Logarithm of Apple Revenue"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))

apple_plot_regular | apple_plot_transformed
```

### Finding a Suitable Model

We start by fitting a cubic trend to the logarithm of the quarterly revenues. The full model is fitted here:

```{r}
#| label: appleCubicFull
#| code-fold: true
#| code-summary: "Show the code"

# Cubic model with standardized time variable

apple_cubic_lm <- apple_ts |>
  model(apple_cubic = TSLM(log(revenue_billions) ~ std_t + I(std_t^2) + I(std_t^3) +qtr )) 
apple_cubic_lm |>
  tidy() |>
  mutate(sig = p.value < 0.05)
```

The quadratic and cubic trend terms are not statistically significant. We now eliminate the cubic term and fit a full model with a quadratic trend.

```{r}
#| label: appleQuadraticFull
#| code-fold: true
#| code-summary: "Show the code"

apple_quad_lm <- apple_ts |>
  model(apple_quad = TSLM(log(revenue_billions) ~ std_t + I(std_t^2) + qtr )) 
apple_quad_lm |>
  tidy() |>
  mutate(sig = p.value < 0.05) 
```

The quadratic trend term is not statistically significant. We will fit a full model with a linear trend.

```{r}
#| label: appleLinearFull
#| code-fold: true
#| code-summary: "Show the code"

# Linear trend with standardized time variable

apple_linear_lm <- apple_ts |>
  model(apple_linear = TSLM(log(revenue_billions) ~ std_t + qtr ))
apple_linear_lm |>
  tidy() |>
  mutate(sig = p.value < 0.05)
```

All the terms are statistically significant in this model. We now compare the models we have fitted using the AIC, AICc, and BIC criterion.

```{r}
#| label: modelComparisonApple
#| output: false
#| code-fold: true
#| code-summary: "Show the code"

model_combined <- apple_ts |>
  model(
    apple_cubic = TSLM(log(revenue_billions) ~ std_t + I(std_t^2) + I(std_t^3) +qtr),
    apple_quad = TSLM(log(revenue_billions) ~ std_t + I(std_t^2)+qtr),
    apple_linear = TSLM(log(revenue_billions) ~ std_t +qtr)
  )

glance(model_combined) |>
  select(.model, AIC, AICc, BIC)
```

```{r}
#| label: tbl-ModelComparisonApple
#| tbl-cap: "Comparison of the AIC, AICc, and BIC values for the models fitted to the logarithm of the simulated time series."
#| echo: false

combined_models <- glance(model_combined) |> 
  select(.model, AIC, AICc, BIC)

minimum <- combined_models |>
  summarize(
    AIC = which(min(AIC)==AIC),
    AICc = which(min(AICc)==AICc),
    BIC = which(min(BIC)==BIC)
  )

combined_models |>
  rename(Model = ".model") |>
  round_df(1) |>
  format_cells(rows = minimum$AIC, cols = 2, "bold") |>
  format_cells(rows = minimum$AICc, cols = 3, "bold") |>
  format_cells(rows = minimum$BIC, cols = 4, "bold") |>
  display_table()
```

We will apply the `apple_linear` model.

### Using the Residuals to Determine the Appropriate Correction

The residuals of this model are illustrated in @fig-residualHistogramAppleRevenue.

```{r}
#| code-fold: true
#| code-summary: "Show the code"
#| label: fig-residualHistogramAppleRevenue
#| fig-cap: "Histogram of the residuals from the reduced model with a linear trend component"

apple_resid_df <- model_combined |> 
  dplyr::select(apple_linear) |>
  residuals() |> 
  as_tibble() |> 
  dplyr::select(.resid) |>
  rename(x = .resid) 
  
apple_resid_df |>
  mutate(density = dnorm(x, mean(apple_resid_df$x), sd(apple_resid_df$x))) |>
  ggplot(aes(x = x)) +
    geom_histogram(aes(y = after_stat(density)),
        color = "white", fill = "#56B4E9", binwidth = 0.05) +
    geom_line(aes(x = x, y = density)) +
    theme_bw() +
    labs(
      x = "Values",
      y = "Frequency",
      title = "Histogram of Residuals from the Reduced Model with a Linear Trend"
    ) +
    theme(
      plot.title = element_text(hjust = 0.5)
    )
```

Using the command `skewness(apple_resid_df$x)`, we compute the skewness of these residuals as: `r skewness(apple_resid_df$x) |> round(3)`. This number is not close to zero (it is between -1 and -0.5) indicating moderate skewness. We would therefore apply the empirical correction to our mean forecast values.

### Applying the Correction Factor

@tbl-correctedModelApple summarizes some of the corrected mean values. Note that in this particular case, the corrected values are very close to the uncorrected values.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

apple_model_values <- model_combined |> 
  dplyr::select(apple_linear) |>
  glance()

apple_model_check <- apple_model_values |>
  mutate(
    sigma = sqrt(sigma2),
    lognorm_cf = exp((1/2) * sigma2),
    empirical_cf = apple_linear_lm |>
      residuals() |>
      pull(.resid) |>
      exp() |>
      mean()) |>
  select(.model, r_squared, sigma2, sigma, lognorm_cf, empirical_cf)

apple_pred <- model_combined |> 
  dplyr::select(apple_linear) |>
  forecast(new_data = apple_ts) |>
  mutate(.mean_correction = .mean * apple_model_check$empirical_cf) |>
  select(t, revenue_billions, .mean, .mean_correction)


```

The log-normal adjustment is $`r sim_model_check |> select(lognorm_cf) |> pull() |> round(5)`$, and the emperical adjustment is $`r sim_model_check |> select(empirical_cf) |> pull() |> round(5)`$.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

apple_pred <- model_combined |> 
  dplyr::select(apple_linear) |>
  forecast(new_data = apple_ts) |>
  mutate(.mean_correction = .mean * apple_model_check$empirical_cf) |>     
  select(t, revenue_billions, .mean, .mean_correction)
```

```{r}
#| label: tbl-correctedModelApple
#| tbl-cap: "Fitted values for the model representing Apple's quarterly revenue"
#| echo: false

apple_pred |>
  as_tibble() |>
  select(!revenue_billions) |>
  select(!dates) |>
  display_partial_table(4,2)
```

### Plotting the Fitted Values

These fitted values are illustrated in @fig-AppleRevenueFittedPlot.

```{r}
#| label: fig-AppleRevenueFittedPlot
#| fig-cap: "Apple Inc.'s quarterly revenue in billions of U.S. dollars through first quarter of 2012 (in black) and the fitted regression model (in blue)"
#| code-fold: true
#| code-summary: "Show the code"

apple_ts |>
  autoplot(.vars = revenue_billions) +
  geom_line(data = apple_pred, aes(x = dates, y = .mean_correction), color = "#56B4E9") +
    labs(
      x = "Quarter",
      y = "Revenue (Billions USD)",
      title = "Apple Revenue in Billions of U.S. Dollars"
    ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5))
```

This time series was used as an example. We are obviously not interested in forecasting future values using this model. However, this is an excellent example of real-world exponential growth in a time series with a seasonal component. Limiting factors prevent exponential growth from being sustainable in the long run. After 2012, the Apple quarterly revenues follow a different, but very impressive, model. This is illustrated in @fig-AppleRevenueAllTime.

```{r}
#| label: fig-AppleRevenueAllTime
#| fig-cap: "Apple Inc.'s quarterly revenue in billions of U.S. dollars; values beginning with the first quarter of 2012 are shown in orange"
#| code-fold: true
#| code-summary: "Show the code"

apple_raw |>
  dplyr::select(dates, revenue_billions) |>
  as_tsibble(index = dates) |>
  autoplot(.vars = revenue_billions) +
  geom_line(
    data = apple_raw |> filter(dates >= my("Jan 2012")), 
    aes(x = dates, y = revenue_billions), 
    color = "#D55E00"
  ) +
  labs(
    x = "Quarter",
    y = "Revenue (Billions USD)",
    title = "Apple Revenue (in Billions USD)"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5))
```

## Small-Group Activity: Industrial Electricity Consumption in Texas

These data represent the amount of electricity used each month for industrial applications in Texas.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

elec_ts <- rio::import("https://byuistats.github.io/timeseries/data/electricity_tx.csv") |>
  dplyr::select(-comments) |>
  mutate(date = my(month),
         month = as.factor(month(date))) |>
  mutate(
    t = 1:n(),
    std_t = (t - mean(t)) / sd(t)
  ) |>
  as_tsibble(index = date)

elec_plot_raw <- elec_ts |>
    autoplot(.vars = megawatthours) +
    labs(
      x = "Month",
      y = "Megawatt-hours",
      title = "Texas' Industrial Electricity Use"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5)
    )

elec_plot_log <- elec_ts |>
    autoplot(.vars = log(megawatthours)) +
    labs(
      x = "Month",
      y = "log(Megwatt-hours)",
      title = "Log of Texas' Industrial Electricity Use"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5)
    )

elec_plot_raw | elec_plot_log
```

<!-- Check Your Understanding -->

::: {.callout-tip icon="false" title="Check Your Understanding"}
Use the Texas industrial electricity consumption data to do the following.

-   Select an appropriate fitted model using the AIC, AICc, or BIC critera.
-   Use the residuals to determine the appropriate correction for the data.
-   Forecast the data for the next 5 years.
-   Apply the appropriate correction to the forecasted values.
-   Plot the fitted (forecasted) values along with the time series.
:::

## Homework Preview (5 min)

-   Review upcoming homework assignment
-   Clarify questions

::: {.callout-note icon="false"}
## Download Homework

<a href="https://byuistats.github.io/timeseries/homework/homework_5_2.qmd" download="homework_5_2.qmd"> homework_5_2.qmd </a>
:::

<!-- Solutions at the bottom of the page -->

<a href="javascript:showhide('Solutions')"
style="font-size:.8em;">Small-Group Activity</a>

::::::::::: {#Solutions style="display:none;"}
#### Small-Group Activity: Retail Sales Code

::: {.callout-caution icon="false" title="Figures" collapse="false"}
@fig-RetailSalesGeneralMerch2 gives the total sales (in millions of U.S. dollars) for the category "all other general merchandise stores (45299)," beginning with January 1998.

```{r}
#| label: fig-RetailSalesGeneralMerch2
#| fig-cap: "Time plot of the total monthly retail sales for all other general merchandise stores (45299)"
#| code-fold: true
#| code-summary: "Show the code"

# Read in retail sales data for "all other general merchandise stores"
retail_ts <- rio::import("https://byuistats.github.io/timeseries/data/retail_by_business_type.parquet") |>
  filter(naics == 45299) |>
  mutate(t = 1:n(),
         month = as.factor((t - 1) %% 12 + 1),
         month = factor(month, levels = 1:12, labels = month.abb)) |>
  mutate(std_t = (t - mean(t)) / sd(t)) |>
  as_tsibble(index = t)

```

@fig-retailSideBySidePlot shows the "All other general merchandise" retail sales data.

```{r}
#| label: fig-retailSideBySidePlot
#| fig-cap: "Time plot of the time series (left) and the natural logarithm of the time series (right)"
#| code-fold: true
#| code-summary: "Show the code"
#| results: asis
#| fig-height: 3.5

plot_raw <- retail_ts |>
    autoplot(.vars = sales_millions) +
    labs(
      x = "Time",
      y = "sales_millions",
      title = "Other General Merchandise Sales"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5)
    )

plot_log <- retail_ts |>
    autoplot(.vars = log(sales_millions)) +
    labs(
      x = "Time",
      y = "log(sales_millions)",
      title = "Logarithm of Other Gen. Merch. Sales"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5)
    )

plot_raw | plot_log
```
:::

<!-- Figures -->

::: {.callout-caution icon="false" title="Cubic Trend" collapse="false"}
```{r}
#| label: fullCubicFittedModel
#| code-fold: true
#| code-summary: "Show the code"

# Cubic model with standardized time variable

cubic_lm <- retail_ts |>
  model(cubic = TSLM(log(sales_millions) ~ std_t + I(std_t^2) + I(std_t^3) + month)) # Note sin6 is omitted
cubic_lm |>
  tidy() |>
  select(!`.model`)|>
  mutate(sig = p.value < 0.05)
```
:::

<!-- Cubic -->

::: {.callout-caution icon="false" title="Quadratic Trend" collapse="false"}
```{r}
#| label: ExponentialQuadraticFull1a-3
#| code-fold: true
#| code-summary: "Show the code"

quad_lm <- retail_ts |>
  model(quad = TSLM(log(sales_millions) ~ std_t + I(std_t^2) + 
    month )) # Note sin6 is omitted
quad_lm |>
  tidy() |>
  select(!`.model`)|>
  mutate(sig = p.value < 0.05) 
```
:::

<!-- Quadratic -->

::: {.callout-caution icon="false" title="Linear Trend" collapse="false"}
```{r}
#| label: ExponentialQuadraticFull2a
#| code-fold: true
#| code-summary: "Show the code"

linear_lm <- retail_ts |>
  model(linear = TSLM(log(sales_millions) ~ std_t +month )) # Note sin6 is omitted
linear_lm |>
  tidy() |>
  select(!`.model`)|>
  mutate(sig = p.value < 0.05) 
```
:::

<!-- Linear -->

::: {.callout-caution icon="false" title="Model Comparison" collapse="false"}
We will now compare the models we fitted above. #tbl-ModelComparison2 gives the AIC, AICc, and BIC of the models fitted above. In addition, other models with a reduced number of Fourier terms are included. For example, the model labeled `reduced_quadratic_fourier_i5` includes linear and quadratic trend terms but also the Fourier terms where $i \le 5$.

```{r}
#| label: modelComparison2
#| output: false
#| code-fold: true
#| code-summary: "Show the code"

model_combined <- retail_ts |>
  model(
    cubic = TSLM(log(sales_millions) ~ std_t + I(std_t^2) + I(std_t^3) + month),
    quadratic = TSLM(log(sales_millions) ~ std_t + I(std_t^2) + month),
    linear = TSLM(log(sales_millions) ~ std_t + month )
  )

glance(model_combined) |>
  select(.model, AIC, AICc, BIC)
```

```{r}
#| label: tbl-ModelComparison2
#| tbl-cap: "Comparison of the AIC, AICc, and BIC values for the models fitted to the logarithm of the retail sales time series."
#| echo: false

combined_models <- glance(model_combined) |> 
  select(.model, AIC, AICc, BIC)

minimum <- combined_models |>
  summarize(
    AIC = which(min(AIC)==AIC),
    AICc = which(min(AICc)==AICc),
    BIC = which(min(BIC)==BIC)
  )

combined_models |>
  rename(Model = ".model") |>
  round_df(1) |>
  format_cells(rows = minimum$AIC, cols = 2, "bold") |>
  format_cells(rows = minimum$AICc, cols = 3, "bold") |>
  format_cells(rows = minimum$BIC, cols = 4, "bold") |>
  display_table()
```

The model with the lowest AIC, AICc, and BIC values is the full cubic model.
:::

<!-- model comparison -->

::: {.callout-caution icon="false" title="Autocorrelation of the Random Component" collapse="false"}
We check for autocorrelation in the random component to determine if using GLS is warranted.

@fig-FullQuadACF illustrates the ACF of the full model with a quadratic trend.

```{r}
#| label: fig-FullQuadACF
#| fig-cap: "ACF of the full model with a quadratic trend"

cubic_ts <- cubic_lm |>
  residuals() 

acf(cubic_ts$.resid, plot=TRUE, lag.max = 25)
```

We observe evidence of autocorrelation in the random terms. In fact, there is something happening on an annual

@fig-FullQuadPACF illustrates the PACF of the reduced model 1 with linear trend.

```{r}
#| label: fig-FullQuadPACF
#| fig-cap: "PACF of the full model with a quadratic trend"
#| code-fold: true
#| code-summary: "Show the code"

alphas_quad <- pacf(cubic_ts$.resid, plot=FALSE, lag.max = 25) 
pacf(cubic_ts$.resid, plot=TRUE, lag.max = 25)
```
:::

<!-- Autocorrelation of the random component -->

::: {.callout-caution icon="false" title="Applying Genearlized Least Squares, GLS" collapse="false"}
Recall that in [Chapter 5, Lesson 1](https://byuistats.github.io/timeseries/chapter_5_lesson_1.html#FittingRegModelWithPACF), we fitted a linear regression model using the value of the partial autocorrelation function for $k=1$. This helps account for the autocorrelation in the residuals.

We will use the PACF when $k=1$ to apply the GLS algorithm. The first few partial autocorrelation values are:

```{r}
#| code-fold: true
#| code-summary: "Show the code"

pacf(cubic_ts$.resid, plot=FALSE, lag.max = 10)
```

The partial autocorrelation when $k=1$ is approximately `r alphas_quad$acf[1] |> round(3)`. We will use this value as we recompute the regression coefficients.

```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Load additional packages
pacman::p_load(tidymodels, multilevelmod,
  nlme, broom.mixed)

lag_1 <- pacf(cubic_ts$.resid, plot=FALSE, lag.max = 10)$acf[1]

temp_spec <- linear_reg() |>
  set_engine("gls", correlation = nlme::corAR1(lag_1))

temp_gls <- temp_spec |>
  fit(log(sales_millions) ~ std_t + I(std_t^2) + I(std_t^3) + month, data = retail_ts)

tidy(temp_gls) |>
  mutate(
    lower = estimate + qnorm(0.025) * std.error,
    upper = estimate + qnorm(0.975) * std.error
  ) 
```

@fig-finalFittedPlot2 illustrates the original time series (in black) and the fitted model (in blue). For reference, a dotted line illustrating the simple least squares line is plotted on this figure for reference. It helps highlight the exponential shape of the trend.

```{r}
#| label: fig-finalFittedPlot2
#| fig-cap: "Time plot of the time series (left) and the natural logarithm of the time series (right)"
#| code-fold: true
#| code-summary: "Show the code"

forecast_df <- cubic_lm |> 
  forecast(retail_ts) |>  # computes the anti-log of the predicted values and returns them as .mean
  as_tibble() |> 
  dplyr::select(std_t, .mean) |> 
  rename(pred = .mean)

retail_ts |>
  left_join(forecast_df, by = "std_t") |>
  as_tsibble(index = t) |>
  autoplot(.vars = sales_millions) +
  geom_line(aes(y = pred), color = "#56B4E9", alpha = 0.75) +
    labs(
      x = "Time",
      y = "Simulated Time Series",
      title = "Time Plot of Simulated Time Series with an Cubic Trend",
      subtitle = "Predicted values based on the full cubic model are given in blue"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5),
      plot.subtitle = element_text(hjust = 0.5)
    )
```

```{r}
#| label: ExponentialQuadraticFull1a-2
#| code-fold: true
#| code-summary: "Show the code"


retail_resid_df <-  cubic_lm |> 
  residuals() |> 
  as_tibble() |> 
  dplyr::select(.resid) |>
  rename(x = .resid) 
  
retail_resid_df |>
  mutate(density = dnorm(x, mean(retail_resid_df$x), sd(retail_resid_df$x))) |>
  ggplot(aes(x = x)) +
    geom_histogram(aes(y = after_stat(density)),
        color = "white", fill = "#56B4E9", binwidth = 0.02) +
    geom_line(aes(x = x, y = density)) +
    theme_bw() +
    labs(
      x = "Values",
      y = "Frequency",
      title = "Histogram of Residuals from the Full Cubic Model"
    ) +
    theme(
      plot.title = element_text(hjust = 0.5)
    )

skewness(retail_resid_df$x)
```
:::

## Small-Group Activity: Industrial Electricity Consumption in Texas Solution

::: {.callout-tip icon="false" title="Check Your Understanding"}
Use the Texas industrial electricity consumption data to do the following.

-   Select an appropriate fitted model using the AIC, AICc, or BIC critera.
-   Use the residuals to determine the appropriate correction for the data.
-   Forecast the data for the next 5 years.
-   Apply the appropriate correction to the forecasted values.
-   Plot the fitted (forecasted) values along with the time series.
:::

```{r}
#| code-fold: true
#| code-summary: "Show the code"

# Cubic model with standardized time variable

elec_cubic_lm <- elec_ts |>
  model(elec_cubic = TSLM(log(megawatthours) ~ std_t + I(std_t^2) + I(std_t^3) + month)) # Note sin6 is omitted
elec_cubic_lm |>
  tidy() |>
  mutate(sig = p.value < 0.05)

# Quadratic model with standardized time variable

elec_quadratic_lm <- elec_ts |>
  model(elec_cubic = TSLM(log(megawatthours) ~ std_t + I(std_t^2) + month)) # Note sin6 is omitted
elec_quadratic_lm |>
  tidy() |>
  mutate(sig = p.value < 0.05)

elec_resid_df <- elec_quadratic_lm |> 
  residuals() |> 
  as_tibble() |> 
  dplyr::select(.resid) |>
  rename(x = .resid) 
  
elec_resid_df |>
  mutate(density = dnorm(x, mean(elec_resid_df$x), sd(elec_resid_df$x))) |>
  ggplot(aes(x = x)) +
    geom_histogram(aes(y = after_stat(density)),
        color = "white", fill = "#56B4E9", binwidth = 0.02) +
    geom_line(aes(x = x, y = density)) +
    theme_bw() +
    labs(
      x = "Values",
      y = "Frequency",
      title = "Histogram of Residuals from the Full Quadratic Model"
    ) +
    theme(
      plot.title = element_text(hjust = 0.5)
    )

skewness(elec_resid_df$x)
```
:::::::::::

<!-- GLS -->

:::
