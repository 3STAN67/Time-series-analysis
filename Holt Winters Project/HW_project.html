<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tristan Farrow">

<title>Holt Winters &amp; Exponential Smoothing</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="HW_project_files/libs/clipboard/clipboard.min.js"></script>
<script src="HW_project_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="HW_project_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="HW_project_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="HW_project_files/libs/quarto-html/popper.min.js"></script>
<script src="HW_project_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="HW_project_files/libs/quarto-html/anchor.min.js"></script>
<link href="HW_project_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="HW_project_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="HW_project_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="HW_project_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="HW_project_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Holt Winters &amp; Exponential Smoothing</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Tristan Farrow </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="exponential-smoothing" class="level2">
<h2 class="anchored" data-anchor-id="exponential-smoothing">Exponential Smoothing</h2>
<p>When analyzing time series data, we often use averages to filter out random fluctuations and reveal underlying patterns. Traditional averages treat all data points equally, summing values over a period and dividing by the count. However, for data that changes dynamically over time, this equal weighting has limitations.</p>
<p>Exponential smoothing offers a more adaptive approach by assigning greater importance to recent observations while still retaining information from the past. It uses smoothing parameters to control how quickly older data points lose their influence. This creates a balance, the model can respond quickly to recent shifts in the data while maintaining a memory of historical trends. Beyond understanding current patterns, exponential smoothing also enables us to forecast future values based on the weighted history of what came before.</p>
</section>
<section id="data" class="level2">
<h2 class="anchored" data-anchor-id="data">Data</h2>
<p><a href="https://www.redfin.com/">Redfin</a>is an online real estate brokerage that helps people buy and sell residential properties. Through its online marketplace and access to Multiple Listing Services (MLS), Redfin compiles extensive housing data, which it shares publicly through its <a href="https://www.redfin.com/news/data-center/">Data Center</a> The site offers valuable data sets, such as median sale prices, active home listings, and median days on market, that provide insight into current regional and national housing trends. By applying exponential smoothing to this data, we can identify underlying patterns and forecast potential future market conditions.</p>
<p>The data set examined here tracks the number of home listings in the U.S. from March 2012 through July 2025. This represents the supply side of the housing market: the total number of homes available for purchase at any given time. According to basic economic principles, when supply increases (assuming steady demand), prices tend to fall; when supply decreases, prices typically rise. For real estate agents and homeowners, understanding these supply trends is essential for gauging market competitiveness, whether it’s a buyer’s market with plenty of options, or a seller’s market with limited inventory.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="HW_project_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="holt-winters-method" class="level2">
<h2 class="anchored" data-anchor-id="holt-winters-method">Holt-Winters Method</h2>
<p>Holt-Winters exponential smoothing is a sophisticated forecasting technique designed specifically for time series data that exhibits both trend and seasonal patterns. Unlike simpler smoothing methods, Holt-Winters maintains three separate components, each with its own smoothing parameter: <span class="math inline">\(\alpha\)</span> (alpha) for the level, <span class="math inline">\(\beta\)</span> (beta) for the trend, and <span class="math inline">\(\gamma\)</span> (gamma) for the seasonal component. These parameters control how responsive the model is to recent observations in each component. Higher values place greater emphasis on new data, allowing the model to adapt quickly to changes, while lower values create more stability by giving greater weight to historical patterns.</p>
<p>Selecting appropriate parameter values is critical for achieving reliable forecasts. While statistical software can automatically optimize these parameters by minimizing error metrics such as Mean Squared Error (MSE) or Mean Absolute Error (MAE), purely algorithmic optimization may not always yield the most practically useful model. The optimal parameters depend heavily on the underlying characteristics of the data and the forecasting context.</p>
<p>Effective use of Holt-Winters requires balancing statistical optimization with domain knowledge. Understanding the data generation process, recognizing external factors that influence patterns, and considering the intended use of the forecast all inform parameter selection. This contextual approach ensures that the model not only fits historical data well but also produces meaningful and actionable predictions for future values.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="HW_project_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>For the model I used the following smoothing parameters:</p>
<p><span class="math inline">\(\alpha\)</span>: 0.3</p>
<p><span class="math inline">\(\beta\)</span>:0.001</p>
<p><span class="math inline">\(\gamma\)</span>:0.0001</p>
<p>For this housing market analysis, I selected a larger <span class="math inline">\(\alpha\)</span> (alpha) value because recent data carries greater weight for real-world decision-making—buyers, sellers, and agents need to understand current market conditions rather than historical averages. The smaller <span class="math inline">\(\beta\)</span> (beta) value produces a smoother, more stable trend line that better captures the long-term direction of the market without overreacting to short-term fluctuations. Finally, I chose a small <span class="math inline">\(\gamma\)</span> (gamma) value because the seasonal pattern in housing listings is highly consistent and predictable from year to year: listings reliably peak in spring and summer, then decline in fall and winter. This stability means we don’t need the model to adjust seasonal estimates aggressively, and a lower gamma value helps prevent over fitting to minor year-to-year variations.</p>
<p>The chart below shows how strongly the residuals (leftover random variation) are correlated with themselves across different time lags. The horizontal axis represents the lag—the number of time periods we’re looking back. Lag 0, the first bar, always equals 1 because any data is perfectly correlated with itself. Lag 1 examines the correlation between consecutive time periods, lag 2 looks two periods back, and so on. The vertical bars indicate the strength of correlation: taller bars mean stronger relationships. The two blue dotted lines form the confidence band, the critical threshold for statistical significance. Bars that fall within this band suggest no meaningful correlation (which is what we want in residuals), while bars extending beyond the band indicate statistically significant patterns that our model may have missed. In an ideal scenario, nearly all bars should remain within the confidence band, confirming that only random noise remains after accounting for trend and seasonality.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="HW_project_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>In the correlogram shown, nearly all bars fall within the blue confidence bands, indicating no statistically significant autocorrelation in the residuals. This is the desired outcome, as it suggests our Holt-Winters model has successfully captured the systematic patterns in the data. It’s worth noting that even with perfectly random residuals, we expect approximately 5% of the bars to extend beyond the confidence bands purely by chance, this is a natural consequence of using 95% confidence intervals.</p>
<p>However, it’s important to distinguish between statistical significance and practical significance. While a bar may technically fall within the confidence band, the overall pattern across multiple lags can still provide valuable information. In this case, the subtle “shape” visible in the correlogram, a slight wave-like pattern in the bar heights, may hint at residual seasonality that the model didn’t fully capture. This doesn’t necessarily indicate a flawed model, but rather suggests that additional diagnostic testing could be valuable. Techniques such as examining seasonal sub series plots or testing alternative seasonal period lengths might reveal whether further refinement would meaningfully improve the model’s performance. Understanding these nuances requires both statistical rigor and contextual knowledge of how housing market dynamics actually behave.</p>
</section>
<section id="forecast" class="level2">
<h2 class="anchored" data-anchor-id="forecast">Forecast</h2>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="HW_project_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>It is essential to recognize that all forecasts are estimates based on historical patterns and the assumption that current underlying conditions will remain relatively stable. Time series models like Holt-Winters extrapolate from the past, meaning they cannot anticipate unforeseen disruptions such as regulatory changes, shifts in market sentiment, economic recessions, or extraordinary events like the COVID-19 pandemic’s impact on housing demand. When the fundamental drivers of a market change, model predictions may quickly become unreliable.</p>
<p>Despite these limitations, forecasts remain valuable tools for informed decision-making. They provide a quantitative baseline for understanding current trends and their likely continuation under stable conditions. For real estate professionals, these projections can guide inventory management, pricing strategies, and timing decisions. For policymakers and economists, they offer insights into market momentum and potential pressure points. Rather than treating forecasts as definitive predictions, they are best used as one input among many, a data-driven perspective that, when combined with qualitative judgment and awareness of emerging risks, supports more thoughtful and strategic planning.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>This analysis demonstrates the practical value of exponential smoothing methods like Holt-Winters for understanding complex time series data. Through careful decomposition and parameter selection, we can separate underlying trends from seasonal fluctuations and random noise, revealing insights that might otherwise remain hidden in the raw data. For housing market analysis specifically, this approach illuminates both the predictable rhythms of buyer and seller behavior and the longer-term structural shifts in inventory supply.</p>
<p>The autocorrelation analysis of the residuals confirmed that the model successfully captured the systematic patterns in the data, with nearly all correlations falling within the expected range of random variation. This validation suggests the chosen smoothing parameters were well-suited to the data’s characteristics. However, the subtle wave-like pattern observed in the correlogram indicates that while the model performs well overall, opportunities for further refinement may exist. Additional diagnostic testing—such as examining alternative seasonal specifications or testing for structural breaks—could potentially enhance the model’s accuracy and provide even deeper insights.</p>
<p>Ultimately, this exercise highlights how statistical methods can transform historical data into actionable intelligence. By understanding not just what happened, but why patterns emerge and how they might continue, decision-makers gain a more nuanced perspective on market dynamics and future possibilities.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>